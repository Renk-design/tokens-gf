'use strict';

var transformDimension = require('./transformDimension.cjs');
var transformHEXRGBa = require('./css/transformHEXRGBa.cjs');
var transformShadow = require('./css/transformShadow.cjs');
var transformFontWeights = require('./transformFontWeights.cjs');
var transformLetterSpacing = require('./css/transformLetterSpacing.cjs');
var transformLineHeight = require('./transformLineHeight.cjs');
var transformTypography = require('./css/transformTypography.cjs');
var transformTypography$1 = require('./compose/transformTypography.cjs');
var transformBorder = require('./css/transformBorder.cjs');
var checkAndEvaluateMath = require('./checkAndEvaluateMath.cjs');
var mapDescriptionToComment = require('./mapDescriptionToComment.cjs');
var transformColorModifiers = require('./color-modifiers/transformColorModifiers.cjs');
var transformOpacity = require('./transformOpacity.cjs');
var parseTokens = require('./parsers/parse-tokens.cjs');

const transforms = [
    'ts/descriptionToComment',
    'ts/size/px',
    'ts/opacity',
    'ts/size/lineheight',
    'ts/typography/fontWeight',
    'ts/resolveMath',
    'ts/size/css/letterspacing',
    'ts/typography/css/fontFamily',
    'ts/typography/css/shorthand',
    'ts/border/css/shorthand',
    'ts/shadow/css/shorthand',
    'ts/color/css/hexrgba',
    'ts/color/modifiers',
];
/**
 * typecasting since this will need to work in browser environment, so we cannot
 * import style-dictionary as it depends on nodejs env
 */
async function registerTransforms(sd, transformOpts) {
    // >= 4.0.0-prelease.2, once SD reaches full release: 4.0.0, sd-transforms will get
    // a breaking release where we always use preprocessors
    // and are no longer backwards compatible with sd 3 or lower
    const supportsPreprocessors = sd.VERSION.match(/4\.0\.0(-prerelease\.([2-9]|[0-9]{2}))/g) !== null;
    // Allow completely disabling the registering of this parser
    // in case people want to combine the expandComposites() utility with their own parser and prevent conflicts
    if (transformOpts?.expand !== false) {
        // expand composition tokens, typography, border, shadow (latter 3 conditionally, as opt-in)
        if (supportsPreprocessors) {
            sd.registerPreprocessor({
                name: 'tokens-studio',
                preprocessor: dictionary => {
                    return parseTokens.parseTokens(dictionary, transformOpts);
                },
            });
        }
    }
    sd.registerTransform({
        name: 'ts/descriptionToComment',
        type: 'attribute',
        // in style-dictionary v4.0.0-prerelease.9, $description is converted to comments (createPropertyFormatter)
        filter: token => !token.$description && token.description,
        transform: token => mapDescriptionToComment.mapDescriptionToComment(token),
    });
    sd.registerTransform({
        name: 'ts/size/px',
        type: 'value',
        filter: token => {
            const type = token.$type ?? token.type;
            return (typeof type === 'string' &&
                ['sizing', 'spacing', 'borderRadius', 'borderWidth', 'fontSizes', 'dimension'].includes(type));
        },
        transform: token => transformDimension.transformDimension(token.$value ?? token.value),
    });
    sd.registerTransform({
        name: 'ts/opacity',
        type: 'value',
        filter: token => (token.$type ?? token.type) === 'opacity',
        transform: token => transformOpacity.transformOpacity(token.$value ?? token.value),
    });
    sd.registerTransform({
        name: 'ts/size/css/letterspacing',
        type: 'value',
        filter: token => (token.$type ?? token.type) === 'letterSpacing',
        transform: token => transformLetterSpacing.transformLetterSpacingForCSS(token.$value ?? token.value),
    });
    sd.registerTransform({
        name: 'ts/size/lineheight',
        type: 'value',
        filter: token => (token.$type ?? token.type) === 'lineHeights',
        transform: token => transformLineHeight.transformLineHeight(token.$value ?? token.value),
    });
    sd.registerTransform({
        name: 'ts/typography/fontWeight',
        type: 'value',
        filter: token => (token.$type ?? token.type) === 'fontWeights',
        transform: token => transformFontWeights.transformFontWeights(token.$value ?? token.value),
    });
    sd.registerTransform({
        name: 'ts/typography/css/fontFamily',
        type: 'value',
        filter: token => (token.$type ?? token.type) === 'fontFamilies',
        transform: token => transformTypography.processFontFamily(token.$value ?? token.value),
    });
    /**
     * The transforms below are transitive transforms, because their values
     * can contain references, e.g.:
     * - rgba({color.r}, {color.g}, 0, 0)
     * - {dimension.scale} * {spacing.sm}
     * - { fontSize: "{foo}" }
     * - { width: "{bar}" }
     * - { blur: "{qux}" }
     * or because the modifications have to be done on this specific token,
     * after resolution, e.g. color modify
     */
    sd.registerTransform({
        name: 'ts/resolveMath',
        type: 'value',
        transitive: true,
        filter: token => typeof (token.$value ?? token.value) === 'string',
        transform: token => checkAndEvaluateMath.checkAndEvaluateMath(token.$value ?? token.value),
    });
    sd.registerTransform({
        name: 'ts/typography/css/shorthand',
        type: 'value',
        transitive: true,
        filter: token => (token.$type ?? token.type) === 'typography',
        transform: token => transformTypography.transformTypographyForCSS(token.$value ?? token.value),
    });
    sd.registerTransform({
        name: 'ts/typography/compose/shorthand',
        type: 'value',
        transitive: true,
        filter: token => (token.$type ?? token.type) === 'typography',
        transform: token => transformTypography$1.transformTypographyForCompose(token.$value ?? token.value),
    });
    sd.registerTransform({
        name: 'ts/border/css/shorthand',
        type: 'value',
        transitive: true,
        filter: token => {
            return (token.$type ?? token.type) === 'border';
        },
        transform: token => transformBorder.transformBorderForCSS(token.$value ?? token.value),
    });
    sd.registerTransform({
        name: 'ts/shadow/css/shorthand',
        type: 'value',
        transitive: true,
        filter: token => {
            const type = token.$type ?? token.type;
            return typeof type === 'string' && ['boxShadow'].includes(type);
        },
        transform: token => {
            const val = token.$value ?? token.value;
            return Array.isArray(val)
                ? val.map(single => transformShadow.transformShadowForCSS(single)).join(', ')
                : transformShadow.transformShadowForCSS(val);
        },
    });
    sd.registerTransform({
        name: 'ts/color/css/hexrgba',
        type: 'value',
        transitive: true,
        filter: token => (token.$type ?? token.type) === 'color',
        transform: token => transformHEXRGBa.transformHEXRGBaForCSS(token.$value ?? token.value),
    });
    sd.registerTransform({
        name: 'ts/color/modifiers',
        type: 'value',
        transitive: true,
        filter: token => (token.$type ?? token.type) === 'color' &&
            token.$extensions &&
            token.$extensions['studio.tokens']?.modify,
        transform: token => transformColorModifiers.transformColorModifiers(token, transformOpts?.['ts/color/modifiers']),
    });
    sd.registerTransformGroup({
        name: 'tokens-studio',
        // add a default name transform, since this is almost always needed
        // it's easy to override by users, adding their own "transforms"
        transforms: [...transforms, 'name/camel'],
    });
}

exports.registerTransforms = registerTransforms;
exports.transforms = transforms;
